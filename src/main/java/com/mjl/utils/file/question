https://www.journaldev.com/java-interview-questions
-----------------------------------------------------
1.abstract class和interface有什么区别?
   1.抽象类中可以有构造方法；接口中不能有
   2.抽象类中可以有普通的成员变量；接口中没有普通的成员变量
   3.抽象类中可以包含非抽象的方法；接口中的所有方法都必须是抽象的
   4.抽象类可以有静态方法；接口中不能包含静态方法
   5.一个类可以实现多个接口但只能继承一个抽象类

2. char型变量能不能存贮一个中文汉字？
     可以，char型变量是用来存储Unicode编码的字符的，Unicode编码字符集中包含了汉字

3. 使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的

4. sleep()和 wait()有什么区别?
    sleep是让线程指定休眠时间，然后继续工作  wait则是等待，直到有线程通知notify（）唤醒他才会重新工作。

5. 简述synchronized和java.util.concurrent.locks.Lock的异同？
    主要相同点：Lock能完成synchronized所实现的所有功能
    主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。

6.XSS攻击与CRSF攻击区别
    CRSF攻击特点是访问了别人的页面，别人利用用户登录状态的cookies伪造用户请求
    XSS攻击主要在脚本攻击，在登录的网站中利用输入脚本内容，获取cookies并发送到自己的网站，这样就可以用别人的身份登录

7.oracle 和mysql的用法区别
    1.oracle对单双引号的要求严一些，一般不允许用双引号；mysql都可以用
    2.oracle分页用rownum；mysql分页用limit
    3.oracle 建表的时候没有auto_increment，所以想要一个字段自增的话需要添加序列，插入时把序列的值插入进去
    4.对空值的判断，name != ""这样在mysql下不会报错的，但是oracle下会报错。在oracle下的要换成name is not null
    5.mysql的用户权限管理，是放到mysql自动带的一个数据库mysql里面的，而oracle是用户权限是根着表空间走的。
    6.group by,在下oracle下用group by的话，group by后面的字段必须在select后面出现，不然会报错的，而mysql却不会。
    7.oracle的表字段类型也没有mysql多，并且有很多不同，例如：mysql的int,float合成了oracle的number型等。
    8.oracle查询时from 表名后面 不能加上as 不然会报错的，select t.username from test as t而在mysql下是可以的。

8.什么是web容器
    web容器是一种服务程序，就是为应用服务器组（如jsp，servlet等）提供一个运行环境，使JSP、servlet直接跟容器中的环境变量接口交互，不必关注其他系统问题。主要有web服务器来实现。
    例如：tomcat、WebLogic，WebSphere等。该容器提供的接口严格遵守j2ee规范的web application标准。我们把遵循以上标准的web服务就叫做j2ee中的web容器。

9.静态内部类的作用
    1.实例化无需外部类实例
    2.静态内部类可以在外部类的静态上下文（如 static 方法、static 块或静态成员定义）中使用。
    3.还有静态内部类只能访问外部类的静态属性和方法，（封装带来的安全）这是与一般内部类的区别

10.什么是内部类？
    内里面定义的类，可以访问外部类的所有成员属性和方法

11.有几种类加载器？
    引导类加载器：加载jdk核心jar
    扩展类加载器：加载jdk扩展jar
    系统类加载器：加载自己写的jar

12.堆内存，老年代，新生代，永久代
    堆中，新生代用来存放很快就会被GC回收掉的或不是很大的对象，新生代采用复制算法，即将新生代分为3个区，较大的Eden区，和两个较小的Survivor区；新生代的GC叫Minor GC，这时会将新生代还存活的对象复制到一个Survior区。
    老年代存放在程序中经过了好几次回收还能存活的对象或特别大的对象，老年大GC叫Major GC；老年代采用标记清除或标记整理算法。有时又叫full GC
    JVM的方法区，也被称作用永久代，里面存放一些被虚拟机加载的类信息、静态变量、常量等数据
    Major GC 是清理老年代。
    Full GC 是清理整个堆空间—包括年轻代和永久代

13.可以作为GC Root 引用点的是：
    栈中的引用的对象。
    方法区中静态引用指向的对象。
    方法区中常量引用指向的对象。
    Native方法中JNI引用的对象。

14.什么叫内存泄漏：
    有一些对象，不满足被回收的条件，但程序又不会再使用，会导致内存泄漏。

15.集合区别
   Set集合不能有重复的元素
   list是有序集合，可以包含重复的元素，类似于动态数组
   hashmap允许键值为null，线程不安全
   hashtable不允许键值为null,线程安全
   treemap用迭代器得到的建是有序的，默认递增，线程不安全
   arraylist线程不安全，vector线程安全

16.JVM、JRE、JDK区别？
   jvm是java编程语言的核心，运行java程序的，负责将字节码转化成机器具体代码，提供内存分配、垃圾回收等核心java功能。
   jre是JVM的实现，提供一个平台去执行java程序
   jdk,java开发工具

17.线程池的缺点
   并发风险，诸如同步错误和死锁，发生线程泄漏的一种情形出现在任务抛出一个 RuntimeException 或一个 Error 时。
   如果池类没有捕捉到它们，那么线程只会退出而线程池的大小将会永久减少一个。当这种情况发生的次数足够多时，线程池最终就为空，
   而且系统将停止，因为没有可用的线程来处理任务。

18.
-------------------------------------------
1、数据库分库； 
    垂直，水平分库，分区，mycat

2、缓存，memcached/redis   原理
    Redis支持丰富的数据类型，最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set；支持持久化

3、分布式RPC框架，hedwig 接口， 原理机制
4、Spring 原理，AOP实现原理
    Spring的两个核心概念是IOC（控制反转）和AOP（面向切面编程）
    对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。
    IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的


5、常用的设计模式
    单例，工厂模式，策略模式，装饰者模式，代理模式，适配器模式，观察者模式

6、JVM内存机制
    程序计数器，java虚拟机栈，本地方法栈，java堆，方法取，直接内存
    JDK 1.7 及以后的版本已经将字符串常量池从永久代中移除

7、数据库索引  B-tree

8、线程同步线程池
9、java基础数据结构， list/map  hashmap的数据存储 put动作 

10.多线程同步和互斥有几种实现方法，都是什么？

-------------------------------------------
1、spring对于事务的处理用到了哪些技术；
    aop？

2、cglib与jdk动态代理，spring处理事务默认用的哪一个；
    jdk

3、spring切面编程原理；
4、concurrentHashMap的实现原理；
    jdk1.5: ConcurrentHashMap使用的是分段锁技术,将ConcurrentHashMap将锁一段一段的存储，然后给每一段数据配一把锁（segment），
    当一个线程占用一把锁（segment）访问其中一段数据的时候，其他段的数据也能被其它的线程访问，默认分配16个segment。
    默认比Hashtable效率提高16倍。
    jdk8: ConcurrentHashMap取消了segment分段锁，而采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。
          synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍

5、java内存模型；
    运行时内存数据区大体上被分为5个区域、两种类型。
    5个数据区包括：方法区、堆区、虚拟机栈、本地方法栈、程序计数器
    两种类型: 所有线程共享的数据区,方法区，堆区；线程私有(隔离)数据区，虚拟机栈，本地方法栈，程序计数器

6、volatile关键字的作用，指令重排的意义，内存屏障；
    volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，保证了每次读写变量都从主内存中读，跳过CPU cache这一步。当一个线程修改了这个变量的值，新值对于其他线程是立即得知的。

7、jvm?垃圾回收原理、永久代的作用；
    http://www.journaldev.com/546/difference-between-jdk-jre-and-jvm-in-java
    jvm是java编程语言的核心，负责将字节码转化成机器具体代码，提供内存分配、垃圾回收等核心java功能

8、hashmap的结构、原理，hash冲突的解决方案；
9、红黑树的结构；
-------------------------------------------
多线程
1.多线程编程的好处？
    多个程序并发的执行以提高程序的效率

2.有哪些不同的线程生命周期？
     new ，runnable， running ，waiting，blocked  ，dead
     开始 就绪 执行 等待  阻塞  死亡

3.对线程优先级的理解
4.线程调度器？
     负责为runnable状态的线程分配cpu时间，线程的执行依赖于它

5.时间分片？
     将可用的cpu时间分配给可用的runnable线程的过程

6.线程之间是如何通信的？
    wait()、notify()和notifyAll()
    全局变量，进程中的线程共享内存，这是比较常用的通信和交互方式

7.死锁的四个必要条件：
    互斥条件、不可剥夺、部分分配、环路条件
    解决方法：打破它的条件

8.如何保证线程安全：
    当多个线程同时访问临界资源（一个对象，对象中的属性，一个文件，一个数据库等）时，就可能会产生线程安全问题。不过，当多个线程执行一个方法，方法内部的局部变量并不是临界资源，因为方法是在栈上执行的，而Java栈是线程私有的，因此不会产生线程安全问题。
    在Java中，提供了两种方式来实现同步互斥访问：synchronized和Lock

并发
1.什么是阻塞队列？
    队列为空时，取、删除操作；队列满了时，往队列添加操作 都会被阻塞
2.如何用阻塞队列实现生产者-消费者问题？

3.什么是原子操作？
    是指一个不受其他操作影响的操作任务单元
-------------------------------------------
1. string stringbuilder stringbuffer区别和使用
    String 字符串常量
    StringBuffer 字符串变量（线程安全）
    StringBuilder 字符串变量（非线程安全）

2. string intern 方法使用原理
3. Integer 内部缓存池
    缓存-128~127这些常用数值

4. try catch finally return会不会执行
       return语句并不是函数的最终出口，如果有finally语句，这在return之后还会执行finally（return的值会暂存在栈里面，等待finally执行后再返回）

5. ArrayList LinkedList 使用区别，注意事项，线程安全

6. HashMap 结构，线程安全， TreeMap的数据结构
7. 常用线程池创建方法，注意事项
    newFixedThreadPool：创建固定大小的线程池。
    newCachedThreadPool：创建一个可缓存的线程池。
    newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
    newScheduledThreadPool：创建一个大小无限的线程池

8. Exception和Error的区别
    Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。
    Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。
    常见的异常：
    ArrayIndexOutOfBoundsException 数组下标越界异常，
    ArithmaticException 算数异常 如除数为零
    NullPointerException 空指针异常
    IllegalArgumentException 不合法参数异常

9. 常见的IO类和注意事项
10. java的类加载机制
    其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段；
    •全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
    •父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
    •缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效

-------------------------------------
1. foreach的实现原理
    foreach对ArrayList的遍历是因为其实现了Iterable接口

2. java里面改变程序执行流的有哪些
3. 父类，子类的类初始化，对象初始化的执行顺序
    执行顺序为：父类静态块儿>子类静态块儿>父类块儿>父类构造>子类块儿>子类构造

4. Integer i1 = hashMap.get("a");
   int i2 = i1
   这个代码有什么问题

5. java持久化的方法有哪些
6. FileInputStream.read(byte[])经过了几次内存拷贝
7. java读取大文件可以有什么优化方式
    使用BufferedReader

8. 如何自定义一个异常
    很多时候，我们自己定义的异常，常常将其定义成为运行时异常，那么我的类就的继承RuntimeException。

9. java编译的时候提示乱码错误是什么原因
    javac -encoding UTF-8 xxx.java

10. java的多态有哪几种
    运行时多态和编译时多态

-----------------------------------
1. cookie和session区别，禁用cookie可以怎么处理
    a、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    b、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。
    c、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    d、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
    建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。
    假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：
       1》 设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开打开了“--enable-trans-sid”选项，让PHP自动跨页传递Session ID。
       2》 手动通过URL传值、隐藏表单传递Session ID。
       3》 用文件、数据库等形式保存Session ID，在跨页过程中手动调用。

2. java对象内存布局
    对象在内存中存储的布局分为三块
    1.对象头
         存储对象自身的运行时数据：Mark Word（在32bit和64bit虚拟机上长度分别为32bit和64bit），包含如下信息：
             对象hashCode
             对象GC分代年龄
             锁状态标志（轻量级锁、重量级锁）
             线程持有的锁（轻量级锁、重量级锁）
             偏向锁相关：偏向锁、自旋锁、轻量级锁以及其他的一些锁优化策略是JDK1.6加入的，这些优化使得Synchronized的性能与ReentrantLock的性能持平，在Synchronized可以满足要求的情况下，优先使用Synchronized，除非是使用一些ReentrantLock独有的功能，例如指定时间等待等。
         类型指针：
             对象指向类元数据的指针（32bit-->32bit，64bit-->64bit(未开启压缩指针)，32bit(开启压缩指针)）
             JVM通过这个指针来确定这个对象是哪个类的实例（根据对象确定其Class的指针）
   2. 实例数据：
         对象真正存储的有效信息
   3. 对齐填充
         JVM要求对象的大小必须是8的整数倍，若不是，需要补位对齐

3. 成员内部类为什么能用访问外部类
    内部类对象持有指向外部类对象的引用

4. final可以提高程序执行效率吗
    是否使用final修饰方法中普通变量对JVM来说没有区别

5. static变量存储在哪里
6. java接口比抽象类方法执行效率差有没有依据
7. 索引的分类，优缺点
    聚集索引,表数据按照索引的顺序来存储的。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页
    非聚集索引，表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，该层紧邻数据页，其行数量与数据表行数据量一致

8. sql语句的优化

--------------------------------------
https://www.journaldev.com/java-interview-questions

1.java10 :
    Local-Variable Type Inference

2.java9 :
    Private methods in Interfaces

3.java8:
    Interface changes with default and static methods
    Functional interfaces and Lambda Expressions
    Java Stream API for collection classes
    Java Date Time API

4.jdk,jre,jvm
    JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre

5.which package is imported by default
    java.lang package

6.Java is Pass by Value or Pass by Reference
    Java is Pass by Value
    https://www.journaldev.com/3884/java-is-pass-by-value-and-not-pass-by-reference

58
